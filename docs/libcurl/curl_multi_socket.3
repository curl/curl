.\" $Id$
.\"
.TH curl_multi_socket 3 "21 Dec 2005" "libcurl 7.16.0" "libcurl Manual"
.SH NAME
curl_multi_socket \- reads/writes available data
.SH SYNOPSIS
#include <curl/curl.h>

CURLMcode curl_multi_socket(CURLM * multi_handle,
                            curl_socket_t sockfd,
                            CURL *easy,
                            curl_socket_callback callback,
                            void *userp);

CURLMcode curl_multi_socket_all(CURLM *multi_handle,
                                curl_socket_callback callback,
                                void *userp);
.SH DESCRIPTION
Alternative versions of \fIcurl_multi_perform()\fP that allows the application
to pass in one of the file descriptors/sockets that have been detected to have
\&"action" on them and let libcurl perform. This allows libcurl to not have to
scan through all possible file descriptors to check for action. The
application is recommended to pass in the \fBeasy\fP argument (or set it to
CURL_EASY_NONE) to make libcurl figure out the internal structure even faster
and easier.  If the easy argument is set to something else than
CURL_EASY_NONE, the \fBsockfd\fP argument will be ignored by libcurl.

These functions inform the application about updates in the socket (file
descriptor) status by doing none, one or multiple calls to the
curl_socket_callback given in the \fBcallback\fP argument. They update the
status with changes since the previous time this function was used. If
\fBcallback\fP is NULL, no callback will be called. A status change may also
be a new timeout only, having the same IN/OUT status as before.

If you want to force libcurl to (re-)check all its internal sockets and
transfers instead of just a single one, you call
\fBcurl_multi_socket_all(3)\fP instead.

An application should call \fBcurl_multi_timeout(3)\fP to figure out how long
it should wait for socket actions \- at most \- before doing the timeout
action: call the \fBcurl_multi_socket(3)\fP function with the \fBsockfd\fP
argument set to CURL_SOCKET_TIMEOUT and the \fBeasy\fP argument set to
CURL_EASY_TIMEOUT.

\fBcurl_multi_perform(3)\fP is the exact equivalent of calling
\fBcurl_multi_socket_all\fP(handle, NULL, NULL);

The socket \fBcallback\fP function uses a prototype like this
.nf

     int curl_socket_callback(CURL *easy,      /* easy handle */
                              curl_socket_t s, /* socket */
                              int action,      /* see values below */
                              void *userp);    /* "private" pointer */

.fi
The callback MUST return 0.

The \fIaction\fP (third) argument to the callback has one of five values:
.RS
.IP "CURL_POLL_NONE (0)"
register, not interested in readiness (yet)
.IP "CURL_POLL_IN (1)"
register, interested in read readiness
.IP "CURL_POLL_OUT (2)"
register, interested in write readiness
.IP "CURL_POLL_INOUT (3)"
register, interested in both read and write readiness
.IP "CURL_POLL_REMOVE (4)"
deregister
.RE
.SH "RETURN VALUE"
CURLMcode type, general libcurl multi interface error code.

If you receive \fICURLM_CALL_MULTI_PERFORM\fP, this basically means that you
should call \fIcurl_multi_perform\fP again, before you select() on more
actions. You don't have to do it immediately, but the return code means that
libcurl may have more data available to return or that there may be more data
to send off before it is "satisfied".

NOTE that this only returns errors etc regarding the whole multi stack. There
might still have occurred problems on individual transfers even when this
function returns OK.
.SH "TYPICAL USAGE"
Call curl_multi_socket_all() first. Setup a "collection" of sockets to
supervise, then when action happens call curl_multi_socket() for the easy
handle that got the action.
.SH AVAILABILITY
This function was added in libcurl 7.16.0
.SH "SEE ALSO"
.BR curl_multi_cleanup "(3), " curl_multi_init "(3), "
.BR curl_multi_fdset "(3), " curl_multi_info_read "(3)"
